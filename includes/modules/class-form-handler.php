<?php
namespace FPR\Modules;

use FPR\Helpers\ProductMapper;
use FPR\Helpers\Logger;

class FormHandler {
	public static function init() {
		add_action('template_redirect', [__CLASS__, 'maybe_store_selection']);

		// Enregistrement AJAX standard
		add_action('wp_ajax_fpr_get_product_id', [__CLASS__, 'handle_ajax_selection']);
		add_action('wp_ajax_nopriv_fpr_get_product_id', [__CLASS__, 'handle_ajax_selection']);
	}

	// ‚úÖ AJAX handler (admin-ajax.php)
	public static function handle_ajax_selection() {
		if (!isset($_POST['count']) || !isset($_POST['courses'])) {
			wp_send_json_error(['message' => 'Param√®tres manquants']);
			exit;
		}

		// Simuler l'appel classique
		$_GET['fpr_store_cart_selection'] = true;
		$_GET['fpr_confirmed'] = true;
		$_SERVER['REQUEST_METHOD'] = 'POST';

		// Injecter les donn√©es JSON directement
		$GLOBALS['fpr_raw_post'] = json_encode([
			'count'   => intval($_POST['count']),
			'courses' => $_POST['courses']
		]);

		// Appel central
		self::maybe_store_selection();
	}

	/**
	 * Standardise le format de l'heure pour un cours
	 * 
	 * @param string $time Le temps √† standardiser
	 * @return string Le temps standardis√©
	 */
	private static function standardize_time_format($time) {
		// Standardize time format (remove any existing formatting)
		$time = preg_replace('/[^0-9:-]/', '', $time);

		// Extract start and end times
		$times = explode('-', $time);
		$start_time = trim($times[0]);
		$end_time = isset($times[1]) ? trim($times[1]) : '';

		// Format times with colons if needed
		if (strlen($start_time) == 4 && strpos($start_time, ':') === false) {
			$start_time = substr($start_time, 0, 2) . ':' . substr($start_time, 2);
		}
		if (strlen($end_time) == 4 && strpos($end_time, ':') === false) {
			$end_time = substr($end_time, 0, 2) . ':' . substr($end_time, 2);
		}

		// Reconstruct the formatted time
		return $start_time . ' - ' . $end_time;
	}

	// üîÅ Handler central pour POST personnalis√© ou AJAX simul√©
	public static function maybe_store_selection() {
		if (!isset($_GET['fpr_store_cart_selection']) || $_SERVER['REQUEST_METHOD'] !== 'POST') {
			Logger::log("üî∏ Requ√™te ignor√©e (pas de param√®tre ou mauvaise m√©thode)");
			return;
		}

		$raw = $GLOBALS['fpr_raw_post'] ?? file_get_contents('php://input');
		Logger::log("üì© Donn√©es brutes re√ßues : $raw");

		$data = json_decode($raw, true);
		if (!isset($data['count']) || !is_array($data['courses'])) {
			Logger::log("‚ùå Param√®tres manquants ou invalides.");
			wp_send_json_error(['message' => 'Param√®tres manquants.']);
			exit;
		}

		$newCourses = $data['courses'];
		Logger::log("‚úÖ {$data['count']} cours re√ßus. Exemple : " . json_encode($newCourses[0]));

		if (!WC()->session) WC()->session = new \WC_Session_Handler();

		// R√©cup√©rer les cours existants avant toute modification
		$existing = WC()->session->get('fpr_selected_courses');
		$existingCourses = $existing ? json_decode($existing, true) : [];

		// ‚úÖ R√©initialisation explicite - seulement si on n'a pas de cours existants ou si on veut vraiment r√©initialiser
		if (isset($_GET['fpr_confirmed']) && empty($existingCourses)) {
			Logger::log("üßπ R√©initialisation des cours (confirmation explicite, aucun cours existant)");
			// Pas besoin de r√©initialiser car $existingCourses est d√©j√† vide
		} else if (isset($_GET['fpr_confirmed']) && isset($_GET['fpr_reset']) && $_GET['fpr_reset'] === '1') {
			// R√©initialisation forc√©e si le param√®tre fpr_reset est pr√©sent et √©gal √† 1
			$existingCourses = [];
			Logger::log("üßπ R√©initialisation forc√©e des cours (param√®tre fpr_reset=1)");
		} else if (isset($_GET['fpr_confirmed'])) {
			// Si on a des cours existants et qu'on ne veut pas r√©initialiser, on les garde
			Logger::log("üîÑ Conservation des cours existants malgr√© fpr_confirmed");
		}

		Logger::log("üìã Cours existants dans la session : " . ($existing ? $existing : "aucun"));
		if (!empty($existingCourses)) {
			Logger::log("üî¢ Nombre de cours existants : " . count($existingCourses));
			Logger::log("üîç Premier cours existant : " . json_encode($existingCourses[0]));

			// Standardiser le format de l'heure pour tous les cours existants
			foreach ($existingCourses as &$course) {
				if (isset($course['time'])) {
					$originalTime = $course['time'];
					$course['time'] = self::standardize_time_format($course['time']);

					if ($originalTime !== $course['time']) {
						Logger::log("  ‚è∞ Standardisation du temps pour un cours existant: " . $originalTime . " -> " . $course['time']);
					}
				}
			}
			unset($course); // D√©truire la r√©f√©rence
		}

		// Standardiser le format de l'heure pour tous les nouveaux cours
		foreach ($newCourses as &$course) {
			if (isset($course['time'])) {
				$originalTime = $course['time'];
				$course['time'] = self::standardize_time_format($course['time']);

				if ($originalTime !== $course['time']) {
					Logger::log("  ‚è∞ Standardisation du temps pour un nouveau cours: " . $originalTime . " -> " . $course['time']);
				}
			}
		}
		unset($course); // D√©truire la r√©f√©rence

		// Fusionner les cours existants et nouveaux
		$mergedCourses = array_merge($existingCourses, $newCourses);
		Logger::log("üîÑ Fusion des cours - Existants: " . count($existingCourses) . " + Nouveaux: " . count($newCourses) . " = Total avant d√©duplication: " . count($mergedCourses));

		// Log d√©taill√© des nouveaux cours
		Logger::log("üì• D√©tail des nouveaux cours:");
		foreach ($newCourses as $index => $course) {
			Logger::log("  üìå Cours #" . ($index + 1) . ": " . json_encode($course));
		}

		// Ne pas √©liminer les doublons - garder tous les cours s√©lectionn√©s
		Logger::log("üîç Processus de d√©duplication d√©sactiv√© - conservation de tous les cours s√©lectionn√©s");

		// Log des cours conserv√©s
		foreach ($mergedCourses as $index => $course) {
			// Cr√©er une cl√© unique pour chaque cours (uniquement pour le log)
			$courseKey = '';
			foreach ($course as $key => $value) {
				if (is_string($value) || is_numeric($value)) {
					$courseKey .= $key . '=' . $value . '|';
				}
			}

			// Log de la cl√© g√©n√©r√©e
			Logger::log("  üîë Cours #" . ($index + 1) . " - Cl√© g√©n√©r√©e: " . $courseKey);
			Logger::log("  ‚úÖ Cours #" . ($index + 1) . " - Conserv√©");
		}

		Logger::log("üßÆ R√©sultat: " . count($mergedCourses) . " cours conserv√©s (y compris les doublons)");

		Logger::log("üîÅ Fusion totale : " . count($mergedCourses) . " cours (sans d√©duplication)");

		// Analyse des dur√©es
		$durations = array_map(fn($c) => trim($c['duration']), $mergedCourses);
		$count1h = 0;
		$countOver = 0;

		// R√©cup√©rer la dur√©e par d√©faut des cours
		$default_duration = get_option('fpr_default_course_duration', '1h');
		Logger::log("‚è±Ô∏è Dur√©e par d√©faut des cours: $default_duration");

		foreach ($durations as $d) {
			// V√©rifier si la dur√©e correspond √† la dur√©e par d√©faut
			if ($d === $default_duration) {
				$count1h++;
				Logger::log("‚úÖ Cours de dur√©e par d√©faut trouv√©: $d");
			} else {
				$countOver++;
				Logger::log("‚è±Ô∏è Cours de dur√©e non standard trouv√©: $d");
			}
		}

		Logger::log("üßÆ R√©partition des cours : dur√©e par d√©faut ($default_duration)=$count1h | autres dur√©es=$countOver");

		// R√©cup√©rer le seuil "√† volont√©" depuis les options d'administration
		$seuilAVolonte = intval(get_option('fpr_aw_threshold', 5));

		$product_id = ProductMapper::get_product_id_smart($count1h, $countOver, $seuilAVolonte);

		if (!$product_id) {
			Logger::log("‚ùå Aucun produit WooCommerce ne correspond.");
			wp_send_json_error(['message' => 'Produit introuvable.']);
			exit;
		}

		// Convertir en JSON pour stockage
		$jsonData = json_encode($mergedCourses);
		Logger::log("üì§ Donn√©es JSON √† enregistrer en session: " . $jsonData);
		Logger::log("üìä Taille des donn√©es JSON: " . strlen($jsonData) . " caract√®res");

		// V√©rifier si les donn√©es sont valides
		$validJson = json_decode($jsonData) !== null;
		Logger::log($validJson ? "‚úÖ JSON valide" : "‚ùå JSON invalide");

		// Enregistrer en session
		WC()->session->set('fpr_selected_courses', $jsonData);
		Logger::log("üß† Donn√©es enregistr√©es en session.");

		// V√©rification imm√©diate
		$storedData = WC()->session->get('fpr_selected_courses');
		Logger::log("üîÑ V√©rification des donn√©es en session: " . ($storedData === $jsonData ? "‚úÖ Identiques" : "‚ùå Diff√©rentes"));
		if ($storedData !== $jsonData) {
			Logger::log("‚ö†Ô∏è ALERTE: Les donn√©es stock√©es ne correspondent pas aux donn√©es envoy√©es!");
			Logger::log("üì• Donn√©es stock√©es: " . $storedData);
		}

		// Op√©rations sur le panier
		Logger::log("üõí D√©but des op√©rations sur le panier");

		if (!WC()->cart) {
			Logger::log("‚ö†Ô∏è Panier non initialis√©, chargement du panier");
			wc_load_cart();
		}

		// Vider le panier
		Logger::log("üóëÔ∏è Vidage du panier");
		$itemsBeforeEmpty = WC()->cart->get_cart_contents_count();
		Logger::log("üìä Nombre d'articles avant vidage: " . $itemsBeforeEmpty);
		WC()->cart->empty_cart();

		// Ajouter le produit au panier
		Logger::log("‚ûï Ajout du produit $product_id au panier");
		$result = WC()->cart->add_to_cart($product_id);

		if ($result === false) {
			Logger::log("‚ùå √âchec de l'ajout du produit");
			// V√©rifier si le produit existe
			$product = wc_get_product($product_id);
			if (!$product) {
				Logger::log("‚ùå Le produit $product_id n'existe pas");
				wp_send_json_error(['message' => 'Le produit s√©lectionn√© n\'existe pas.']);
				exit;
			}

			// V√©rifier si le produit est en stock
			if (!$product->is_in_stock()) {
				Logger::log("‚ùå Le produit $product_id n'est pas en stock");
				wp_send_json_error(['message' => 'Le produit s√©lectionn√© n\'est pas en stock.']);
				exit;
			}

			// Erreur g√©n√©rique si aucune cause sp√©cifique n'est identifi√©e
			Logger::log("‚ùå Erreur inconnue lors de l'ajout du produit $product_id au panier");
			wp_send_json_error(['message' => 'Une erreur est survenue lors de l\'ajout du produit au panier.']);
			exit;
		}

		Logger::log("‚úÖ Produit ajout√© avec succ√®s");

		// Calculer les totaux
		Logger::log("üßÆ Calcul des totaux du panier");
		WC()->cart->calculate_totals();

		// V√©rifier le contenu du panier
		$itemsAfterAdd = WC()->cart->get_cart_contents_count();
		Logger::log("üìä Nombre d'articles apr√®s ajout: " . $itemsAfterAdd);

		// V√©rifier que le panier n'est pas vide
		if ($itemsAfterAdd == 0) {
			Logger::log("‚ùå Le panier est vide apr√®s tentative d'ajout du produit");
			wp_send_json_error(['message' => 'Une erreur est survenue lors de l\'ajout des cours au panier. Le panier est vide.']);
			exit;
		}

		// V√©rifier que les donn√©es de cours sont bien attach√©es au produit dans le panier
		$cartItems = WC()->cart->get_cart();
		Logger::log("üîç V√©rification des donn√©es de cours dans le panier");
		$coursesAttached = false;

		foreach ($cartItems as $cartItemKey => $cartItem) {
			if (isset($cartItem['fpr_selected_courses'])) {
				Logger::log("‚úÖ Donn√©es de cours trouv√©es pour l'article $cartItemKey");
				$coursesInCart = is_string($cartItem['fpr_selected_courses']) 
					? json_decode($cartItem['fpr_selected_courses'], true) 
					: $cartItem['fpr_selected_courses'];
				Logger::log("üìä Nombre de cours dans l'article: " . (is_array($coursesInCart) ? count($coursesInCart) : "N/A"));
				$coursesAttached = true;
			} else {
				Logger::log("‚ùå Aucune donn√©e de cours trouv√©e pour l'article $cartItemKey");
			}
		}

		// V√©rifier que les donn√©es de cours sont bien attach√©es √† au moins un article
		if (!$coursesAttached) {
			Logger::log("‚ùå Aucune donn√©e de cours n'a √©t√© attach√©e aux articles du panier");
			wp_send_json_error(['message' => 'Une erreur est survenue lors de l\'ajout des cours au panier. Les donn√©es de cours n\'ont pas √©t√© attach√©es.']);
			exit;
		}

		Logger::log("üõí Produit $product_id ajout√© au panier avec succ√®s.");
		wp_send_json_success(['added_product_id' => $product_id]);
		exit;
	}
}
